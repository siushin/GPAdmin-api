---
alwaysApply: true
scope:
    filePatterns: [ "*.php", "app/**/*.php" ]  # 仅对Laravel项目的PHP文件生效
    aiScenarios: [ "generate", "refactor", "debug" ]  # AI生成/重构/调试时都遵守
    version: "1.0.0"  # 规则版本(便于迭代)
---

# 【数据库模块】规则约束

## 1. 核心原则

**所有主键ID，都必须使用助手函数 `generateId()` 来指定生成。**

**如果需要对比新旧数据，找出差异部分，进行新增、更新、删除操作的，必须使用助手函数 `compareDbDataDiff()`。**

**所有分页数据、列表数据查询时，都必须支持 `account_id` 的完全匹配查询。**

## 2. Eloquent ORM/数据库使用约束

**禁止直接使用 DB 类操作数据库表**：必须为每个数据表创建对应的 Eloquent 模型，所有数据库操作必须通过模型进行。

**使用 Eloquent ORM 进行数据库操作**：

- 使用模型的 `query()` 方法构建查询
- 使用模型的 `create()`、`update()`、`delete()` 方法进行数据操作

**参数必填项校验**：必须使用 `self::checkEmptyParam($params, ['organization_type']);` 进行参数校验，需要 `use ParamTool`。

**构造where数组**：必须使用
`$where = self::buildWhereData($params, ['organization_type' => '=', 'organization_name' => 'like']);` 构造查询条件，需要
`use ModelTool`。

第二个参数支持的查询类型：

- `'='` - 完全匹配查询，例如：`'organization_type' => '='`
- `'like'` - 模糊查询（LIKE），例如：`'organization_name' => 'like'`
- `'date_range'` 或 `'time_range'` - 日期/时间范围查询，需要指定字段名，例如：`'date_range' => 'created_at'` 或
  `'time_range' => 'created_at'`
- `'keyword'` - 关键词查询，支持以下格式：
  - 单个字段：`'keyword' => 'content'`
  - 多个字段（用 `|` 分隔）：`'keyword' => 'content|ip_location'`
  - 字段数组：`'keyword' => ['before_data', 'after_data', 'description']`

## 3. 主键ID生成规范

### 3.1 必须使用 generateId() 函数

- **禁止**：直接使用数据库自增（AUTO_INCREMENT）或手动指定ID值
- **必须**：使用 `generateId()` 助手函数生成主键ID
- **适用范围**：所有需要指定主键ID的数据创建操作

### 3.2 使用场景

以下场景必须使用 `generateId()`：

1. **Model::create() 创建记录时**
2. **Model::query()->create() 创建记录时**
3. **Factory 定义中**
4. **Seeder 数据填充时**
5. **任何需要手动指定主键ID的场景**

### 3.3 数据差异对比

**重要**：如果需要对比新旧数据，找出差异部分，进行新增、更新、删除操作的，必须使用助手函数 `compareDbDataDiff()`。

- **禁止**：手动编写循环对比新旧数据的逻辑
- **必须**：使用 `compareDbDataDiff()` 助手函数自动计算差异
- **适用范围**：所有需要批量处理数据变更的场景（如批量更新关联数据、同步数据等）

### 3.4 account_id 查询支持规范

**重要**：所有分页数据、列表数据查询时，都必须支持 `account_id` 的完全匹配查询。

- **必须**：在使用 `fastGetPageData()` 或 `fastGetAllData()` 等方法时，必须在查询配置数组中包含 `'account_id' => '='`
- **适用范围**：所有使用封装的分页/列表查询方法的场景
- **目的**：确保普通用户只能查看自己的数据，管理员可以按账号ID筛选数据

## 4. 字段更新检查规范

**重要**：在更新数据时，检查字段是否存在必须使用 `array_key_exists()` 而不是 `isset()`。

- **禁止**：使用 `isset($params[$field])` 或 `if ($params[$field])` 来检查字段是否存在
- **必须**：使用 `array_key_exists($field, $params)` 来检查字段是否存在
- **原因**：`isset()` 对于值为 `null` 的情况会返回 `false`，而 `if ($params[$field])` 对于值为 `0`、`false`、`''` 等 falsy 值也会返回 `false`，导致这些值无法正确更新
- **适用范围**：所有更新操作中需要检查字段是否存在的场景

**示例**：

```php
// ❌ 错误：status 为 0 时无法更新
if (isset($params['status'])) {
    $update_data['status'] = $params['status'];
}

// ❌ 错误：status 为 0 时无法更新
if ($params['status']) {
    $update_data['status'] = $params['status'];
}

// ✅ 正确：status 为 0 时也能正确更新
if (array_key_exists('status', $params)) {
    $update_data['status'] = $params['status'];
}
```

### 4.1 trimValueArray 处理规范

**重要**：如果更新方法中使用了 `trimValueArray()`，必须特别注意值为 `0`、`false` 等 falsy 值的字段。

- **问题**：`trimValueArray()` 可能会移除某些值（取决于 `$values` 参数），如果字段值为 `0` 且不在 `$values` 列表中，通常不会被移除，但为了安全起见，建议在 `trimValueArray()` 之前保存这些关键字段的值
- **解决方案**：对于可能为 `0` 的关键字段（如 `status`、`sort_order` 等），在调用 `trimValueArray()` 之前先保存其值，如果被移除了则恢复

**示例**：

```php
// ✅ 正确：在 trimValueArray 之前保存 status 的值
public static function updateDepartment(array $params): array
{
    // 保存可能为 0 的关键字段值
    $statusValue = array_key_exists('status', $params) ? $params['status'] : null;

    self::trimValueArray($params, [], [null]);

    // 如果 status 被移除了，但原本存在，则恢复它
    if ($statusValue !== null && !array_key_exists('status', $params)) {
        $params['status'] = $statusValue;
    }

    // ... 后续处理
}
```

## 5. 重要提醒

- **所有主键ID字段**，在创建记录时都必须使用 `generateId()` 函数
- 不要依赖数据库的 AUTO_INCREMENT 功能
- 不要手动指定ID值（如硬编码数字）
- 确保每个需要主键ID的创建操作都包含 `'id' => generateId()`
- **所有需要对比新旧数据差异的场景**，都必须使用 `compareDbDataDiff()` 助手函数
- 不要手动编写数据对比逻辑，应使用 `compareDbDataDiff()` 自动计算新增、更新、删除的差异
- **所有分页/列表查询方法**，都必须支持 `account_id` 的完全匹配查询（`'account_id' => '='`）
- 确保普通用户只能查看自己的数据，管理员可以按账号ID筛选数据
- **所有更新操作**，检查字段是否存在时必须使用 `array_key_exists()` 而不是 `isset()` 或 `if ($value)`
